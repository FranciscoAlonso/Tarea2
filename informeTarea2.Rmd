---
title: "Tarea 2"
author: "Francisco Alonso"
date: "April 27, 2016"
output: pdf_document
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
  library(foreign)
  library(caret)
  library(PerformanceAnalytics)
  library(dplyr)
  library(class)
```

#Ejercicio 1

Se aplica el proceso de minería de de datos sobre el conjunto de datos "SEISMIC-BUMPS", en este están clasificados eventos en minas según si en el siguente estado ocurrió o no un movimiento sísmico con mucha energía, este se clasifica como "estado peligroso" (1) o "estado no peligroso" (0) según un conjunto de 13 variables correspondientes a mediciones de energía en movimientos sísmicos y otras 5 que indican, en general, el nivel de peligrosidad de los movimientos ya ocurridos.

Se prepara la data para la creación del modelo, es necesario que las variables nominales sean convertidas a valores numéricos, luego se divide el conjunto de datos en un conjunto de entrenamiento y uno de prueba para construir nueve modelos usando el algoritmo k-vecinos más cercanos (k nearest neighborgs - knn) variando el número de grupos de dos a diez. Por último se toman medidas del error de predicción y g-medias para comparar cada modelo construido.

```{r echo=FALSE, message=FALSE, warning=FALSE}
  seismic <- read.arff(file = "seismic-bumps.arff")
  seismic2 <- seismic
  seismic2$seismic <- as.integer(seismic$seismic)
  seismic2$seismoacoustic <- as.integer(seismic$seismoacoustic)
  seismic2$shift <- as.integer(seismic$shift)
  seismic2$ghazard <- as.integer(seismic$ghazard)
  seismic2$class<- as.integer(seismic$class)
  
  smp_size <- floor(0.75 * nrow(seismic))
  set.seed(42)
  train_ind <- sample(seq_len(nrow(seismic)), size = smp_size)
  seismicTrain <- seismic2[train_ind, ]
  seismicTest <- seismic2[-train_ind, ]
  
  models <- c()
  geoMeans <- c()
  errors <- c()
  
  for(i in 2:10)
  {
    m <- knn(train = seismicTrain, test = seismicTest, cl = seismicTrain$class, k = i)
    models <- cbind(models, m)
    cm <- confusionMatrix(m, seismicTest$class)
    geoMeans <- c(geoMeans, mean.geometric(cm$byClass))
    errors <- c(errors, ((cm$table[2]+cm$table[3])/sum(cm$table)) )
  }
  plot(2:10, errors, main = "Error de predicción para cada valor K", ylim = c(0.0, 0.15), xlab = "Valores de K", ylab = "Error de predicción")
  plot(2:10, geoMeans, main = "G-medias para cada valor K", ylim = c(0.5, 0.7), xlab = "Valores de K", ylab = "G-medias")

```

Se observa que el error de predicción se reduce al usar k = 9, sin embargo dado que esta métrica es susceptible al sesgo entre clases y observamos que las clases no están bien representadas en el conjunsto de datos, nos referimos al valor de g-medias para determinar que el valor de k apropiado es cuatro.

```{r, echo=FALSE}
  summary(seismic$class)
  plot(x = seismic$class, xlab = "Clase", ylab = "frecuencia", ylim = c(0,3000))
```


#Ejercicio 2

Se aplica el proceso de minerá de datos para construir un modelo descriptivo basado en agrupación sobre el conjunto de datos "WHOLESALE CUSTOMERS" para determinar patrones de compra de clientes. 

El conjunto de datos contiene algunos outliers que pueden afectar el resultado del algoritmo k-medias, en la etapa de limpieza se procede a eliminar estos clientes. Además es necesario eliminar los atributos "Channel" y "Region" ya que funcionan como identificadores y no son útiles para la agrupación.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
  salesCostumers <- read.csv("Wholesale customers data.csv")
  idx.to.remove <-integer(0) 
  for (c in 3:8){ 
    col.order <-order(salesCostumers[,c],decreasing=T) 
    idx <-head(col.order, 5) 
    idx.to.remove <-union(idx.to.remove,idx)
  }
  
  #length(idx.to.remove) 
  #salesCostumers[idx.to.remove,] 
  data.rm.top<-salesCostumers[-c(idx.to.remove),] 
  
  set.seed(42)
  k <-kmeans(data.rm.top[,-c(1,2)], centers=5)
```

Para validar el modelo se observan, para varios modelos con distintos valores de k y varias repeticiones, la suma del cuadrado de las distancias entre los elementos de los grupos y los centros (withinss) y la suma del cuadrado de las distancias entre los centros de los grupos (betweenss).

```{r, echo=FALSE, message=FALSE, warning=FALSE}
kvalues<-2:20 
tries <- 100 
avgTotalWithinss <- integer(length(kvalues)) #Set up an empty vector to hold all of points
avgTotalBetweenss <- integer(length(kvalues))
for(v in kvalues){ # For each value of the range variable
    totalWithinss <- integer(tries) #Set up an empty vector to hold the 100 tries
    totalBetweenss <- integer(tries)
    for(i in 1:tries){
        kMeansHelper <- kmeans(data.rm.top,centers=v) #Run kmeans
        totalWithinss[i] <- kMeansHelper$tot.withinss #Store the total withinss
        totalBetweenss[i] <- kMeansHelper$betweenss
    }
    avgTotalWithinss[v-1] <- mean(totalWithinss) #Average the 100 total withinss
    avgTotalBetweenss[v-1] <- mean(totalBetweenss)
}
plot(kvalues,avgTotalWithinss, type="b", main="Total de withinss para varios K",
     ylab="Promedio total de withinss",
     xlab="Valor de K")
plot(kvalues,avgTotalBetweenss, type="b", main="Total de betweenss para varios K",
     ylab="Promedio total de betweenss",
     xlab="Valor de K")
```

Se observa en los gráficos que a partir de 5 grupos la ganancia en las distancias se reduce lo suficiente como para seleccionar este valor de K.

Luego se construye el modelo usando el algoritmo K-Means con k igual a 5 y a continuación se muestran los centros de cada uno de los cinco grupos creados y el número de clientes en cada grupo.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
  print(k$centers) #cluster centers
  print(table(k$cluster)) #Give a count of data points in each cluster
```

De las características observadas en cada grupo podemos observar lo siguiente para cada uno de estos:

- Grupo 1: Tiene un consumo alto de productos frescos y un consumo medio del resto de las categorías.
- Grupo 2: Tiene un alto consumo de productos lácteos, enlatados, detergentes y delicateses, mientras mantienen un consumo medio en las demás categorías.
- Grupo 3: Tienen un consumo medio en comparación con el resto de los grupos en todas las categorías.
- Grupo 4: Mantiene un consumo medio o bajo en todas las categorías, exceptuando la de productos congelados en donde presentan un mayor consumo respecto a las demás categorías. 
- Grupo 5: Tiene el mayor consumo de productos frescos y congelados.












